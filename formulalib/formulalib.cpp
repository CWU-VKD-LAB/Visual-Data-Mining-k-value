#include "formulalib.h"

//***********************************************************************************************
// constructor used to create with the child
//***********************************************************************************************

parenthesis_node_t::parenthesis_node_t(formula_node_t* _bottom)
{
	bottom = _bottom;
}

//***********************************************************************************************
// destructor, mainly destroy the child before exiting
//***********************************************************************************************

parenthesis_node_t::~parenthesis_node_t(void)
{
	if (bottom) delete (bottom);
}

//***********************************************************************************************
// return the value of the parenthesis
//***********************************************************************************************

bool parenthesis_node_t::value(bit_vector_t& x)
{
	if (bottom) return bottom->value(x);
	else return false;
}

//***********************************************************************************************
// Clone funtion, used to clone the tree
//***********************************************************************************************

formula_node_t* parenthesis_node_t::clone(void)
{
	if (bottom) return new parenthesis_node_t(bottom->clone());
	else return new parenthesis_node_t();
}

//***********************************************************************************************
// default variable constructor
//***********************************************************************************************

variable_node_t::variable_node_t(void) :
	i(0)
{
}

//***********************************************************************************************
// copy constructor
//***********************************************************************************************

variable_node_t::variable_node_t(variable_node_t& src)
{
	i = src.i;
}

//***********************************************************************************************
//  constructor by number
//***********************************************************************************************

variable_node_t::variable_node_t(size_t _i)
{
	i = _i;
}

//***********************************************************************************************
// copy operator
//***********************************************************************************************

variable_node_t& variable_node_t::operator=(variable_node_t& src)
{
	i = src.i;
	return *this;
}

//***********************************************************************************************
// destructor
//***********************************************************************************************

variable_node_t::~variable_node_t(void)
{
}

//***********************************************************************************************
// return the value of the variable
//***********************************************************************************************

bool variable_node_t::value(bit_vector_t& x)
{
	return x[i];
}

//***********************************************************************************************
// clone itself
//***********************************************************************************************

formula_node_t* variable_node_t::clone(void)
{
	return new variable_node_t(i);
}

//***********************************************************************************************
// creator using a child
//***********************************************************************************************

not_node_t::not_node_t(formula_node_t* child)
{
	bottom = child;
}

//***********************************************************************************************
//  copy operator
//***********************************************************************************************

not_node_t& not_node_t::operator=(not_node_t& src)
{
	return *this;
}

//***********************************************************************************************
// destructor destroy the tree
//***********************************************************************************************

not_node_t::~not_node_t(void)
{
	if (bottom) delete(bottom);
}

//***********************************************************************************************
// return not of the child
//***********************************************************************************************

bool not_node_t::value(bit_vector_t& x)
{
	if (bottom) return !bottom->value(x);
	else return false;
}

//***********************************************************************************************
// clone the tree
//***********************************************************************************************

formula_node_t* not_node_t::clone(void)
{
	if (bottom) return new not_node_t(bottom->clone());
	else return new not_node_t();
}

//***********************************************************************************************
// constructor using left and right childs
//***********************************************************************************************

and_node_t::and_node_t(formula_node_t* _left, formula_node_t* _right)
{
	left = _left;
	right = _right;
}

//***********************************************************************************************
// destructor, destroy the childs
//***********************************************************************************************

and_node_t::~and_node_t(void)
{
	if (left) delete (left);
	if (right) delete (right);
}

//***********************************************************************************************
// return an and of the childs
//***********************************************************************************************

bool and_node_t::value(bit_vector_t& x)
{
	if (right && left) return left->value(x) & right->value(x);
	else return false;
}

//***********************************************************************************************
// clone the tree
//***********************************************************************************************

formula_node_t* and_node_t::clone(void)
{
	if (left && right) return new and_node_t(left->clone(), right->clone());
	else return new and_node_t();
}

//***********************************************************************************************
// constructor using left or right childs
//***********************************************************************************************

or_node_t::or_node_t(formula_node_t* _left, formula_node_t* _right)
{
	left = _left;
	right = _right;
}

//***********************************************************************************************
// destructor, destroy the childs
//***********************************************************************************************

or_node_t::~or_node_t(void)
{
	if (left) delete (left);
	if (right) delete (right);
}

//***********************************************************************************************
// return an or of the childs
//***********************************************************************************************

bool or_node_t::value(bit_vector_t& x)
{
	if (right && left) return left->value(x) | right->value(x);
	else return false;
}

//***********************************************************************************************
// clone the tree
//***********************************************************************************************

formula_node_t* or_node_t::clone(void)
{
	if (left && right) return new or_node_t(left->clone(), right->clone());
	else return new or_node_t();
}

//***********************************************************************************************
// Default creator
//***********************************************************************************************

formula_t::formula_t(void) :
	tree(NULL)
{
}

//***********************************************************************************************
// Copy constructor
//***********************************************************************************************

formula_t::formula_t(formula_t& src)
{
	if (src.tree) tree = src.tree->clone();
}

//***********************************************************************************************
// copy operator
//***********************************************************************************************

formula_t::formula_t(const char* const expr)
{
	// to be done using the parser
}


//***********************************************************************************************
// copy operator
//***********************************************************************************************

formula_t& formula_t::operator= (formula_t& src)
{
	if (tree) delete (tree);
	if (src.tree) tree = src.tree->clone();
	return *this;
}

//***********************************************************************************************
// destructor
//***********************************************************************************************

formula_t::~formula_t(void)
{
	if (tree) delete (tree);
}

//***********************************************************************************************
// return the value using the bit_vector x
//***********************************************************************************************

bool formula_t::valueof(bit_vector_t& x)
{
	if (tree) return tree->value(x);
	else return false;
}

//***********************************************************************************************
// parse the line and create the tree
//***********************************************************************************************

bool formula_t::create(const char* const expr)
{
	return true;
}
