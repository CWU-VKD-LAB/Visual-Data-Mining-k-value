#pragma once

/* **********************************************************************
   *  UPDATE 3/28/2022 - Harlow Huber  
   *	The files belonging to the Visual Data Mining project are quite old and were built in Visual C++ 6.0 in, I presume, C++98.
   *	This project is being reimagined in Visual Studio 2022 in C++20. I do not know the format of the CHANGE LOG, so I will
   *	put my changes below. All functionality will remain the same, or exceedingly similar.
   *	All previous code comments will remain, for now, as a reference.
   *
   *  BUG FIXES 3/28/2022 - Harlow Huber
   *	in display(), "ofstream" changed to "std::ofstream"
   *	removed "HanselChainSet::" from private function declarations
   * 
   *  FILE        : hanselchainset.h
   *  NAME        : Hansel Chain Set Specification
   *  OWNER       : Jay Summet     (only owner can make changes)
   *  VERSION     : 1.1            (major change.minor change)
   **
   ** Version modified by Florian DELIZY
   ** for being now reusable (I did delete some features that I did not
   ** need ...) it is now a dll
   **
   *
   *  CHANGE LOG  :
   *     VERSION #  DATE      WHO COMMENT
   *     ---------------------------------------------------------------
   *     0.1.0      11.21.98  JWS Created file
   *     0.2.0      11.21.98  SAF Added retrieveChainShift stub
   *     0.3.0      11.21.98  SAF Updated generateInquiry to return
   *                                 FALSE if done generating
   *     1.0.0      11.23.98  ALL Initial Client Release
   *     1.1.0      11.28.98  SAF Added file output for display
   *
   *  SYSTEM      : ANSI C++ - should build on everything.
   *
   *  DESCRIPTION : N/A
   *
   *  INCLUDES    : (iostream.h) I/O Streams
   *                (fstream.h) File Stream
   *                (vector.h)   Vector class
   *                (hanselchain.h) Hansel Chain class
   *
   *  TODO        : N/A
   *
   *************************************************************************/

#include "pch.h"
#include "hanselchain.h"


#ifndef _HANSELCHAINSET_H
#define _HANSELCHAINSET_H

// Purpose: Contains all Hansel Chains in a binary space
class __declspec(dllexport) HanselChainSet {
public:
	// Purpose: Creates a new set of Hansel Chains based on n elements per vector
	// Input:	number of elements per vector
	// Output:	N/A
	// Returns:	N/A
	// Notes:	N/A
	HanselChainSet(int n);

	// Purpose: Generates a new inquiry if function not completely expanded
	// Input:	N/A
	// Output:	length of the Chain the vector is from
	// Returns:	next inquiry vector, if existent
	// Notes:	Calls HanselChain::retrieveNextUnexpandedVector in each chain
	//             until we run out of chains
	Vector* generateInquiry(int& nextInquiryChainLength);

	// Purpose: Expands the vectors based on a known vector generated by oracle's answer
	// Input:	vector from which to expand other vectors
	//          length of the Chain from which the vector was taken
	// Output:	N/A
	// Returns:	N/A
	// Notes:	calls HanselChain::expandChainVectors with expandFrom vector on each Chain
	//             of length L or (L + 2), where L is the length of the Chain that
	//             the expandFrom vector is from
	//void expandVectorValues(Vector expandFrom, int length);

	// Purpose: Displays the Hansel Chain set (i.e. binary space of function)
	//             to a file
	// Input:	pointer to file stream
	// Output:	N/A
	// Returns:	N/A
	// Notes:	displays to outputFile the vectors, their values, and their inquiry bits
	void display(std::ofstream& outputFile) const;

	// Purpose: Displays the Hansel Chain set (i.e. binary space of function)
	// Input:	N/A
	// Output:	N/A
	// Returns:	N/A
	// Notes:	displays to screen the vectors, their values, and their inquiry bits
	void displayQuestions(void);

	/*
		// Purpose: Gives each hansel chain the MonBoolFunc to put the switchpoint into.
		// Input:	MonotoneBooleanFunction
		// Output:	N/A
		// Returns:	N/A
		// Notes:	N/A
		void fillOutputMonoBoolFunc(MonotoneBooleanFunction& Func);

			  Sorry I don't need it and it would make many problems ... so it goes away
			  FD
	*/

	// some people never learn, so there it is what you would have needed ...
	// .FD

	HanselChain* operator[] (int i) // I know it should return a reference, but all objects
									 // of this program should be allmost rewritten, I just
									 // import it, not write it ... FD
	{
		if (i < 0 || i > length) return NULL; // I am sure it could crash

		int j;
		chainNode* cur = ChainListStart;

		for (j = i; j > 0 && cur; j--)
			cur = cur->nextNode;
		return cur->data;

	}

	int get_length(void) { return length; }


private:
	void MagicallyCreateNextLevel(void);
	void addChain(HanselChain* Chain);
	struct chainNode
	{
		HanselChain* data;
		chainNode* nextNode;
	};
	int length; // Number of chains we hold	
	int maxChainLength;
	chainNode* ChainListStart;
	chainNode* ChainListEnd;
};	// HanselChainSet

#endif